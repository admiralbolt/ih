<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ih.imgproc &mdash; Image Harvest 1.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-3.2.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-3.2.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Image Harvest 1.0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Image Harvest</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_core1.html">Core Processing Example #1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_core2.html">Core Processing Example #2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_color1.html">Color Filter In Depth #1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_seed.html">Seed Processing Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_camera1.html">Camera Processing Example #1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_script_camera2.html">Camera Processing Example #2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_workflow_1.html">Workflow Example #1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_workflow_2.html">OSG Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_workflow_2.html#creating-the-ih-distribution">Creating the ih Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ex_workflow_2.html#creating-ssh-keys">Creating ssh Keys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arkansas_workshop_july_2015.html">Arkansas Workshop July 2015</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../processing.html">Image Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../viewer.html">Image Processing Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indexing.html">Image Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflowimage.html">Image Processing Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflowstats.html">Statistics Workflows</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <h1>Source code for ih.imgproc</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file is part of Image Harvest.</span>

<span class="sd">Image Harvest is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">Image Harvest is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with Image Harvest.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">.. module:: imgproc</span>
<span class="sd">    :platform: Mac, Linux</span>
<span class="sd">    :synopsis: Image processing function wrappers to opencv.</span>

<span class="sd">.. moduleauthor:: Avi Knecht &lt;avi@kurtknecht.com&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">conf</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">pymeanshift</span> <span class="kn">as</span> <span class="nn">pms</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">class</span> <span class="nc">ColorFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Color Filtration logic container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;True&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;False&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
            <span class="s">&quot;and&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="s">&quot;or&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="s">&quot;&gt;&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;&lt;&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;&gt;=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;+&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;-&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;.&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">*</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;/&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">left</span> <span class="o">/</span> <span class="n">right</span><span class="p">,</span>
            <span class="s">&quot;max&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="s">&quot;min&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="s">&quot;not&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">left</span><span class="p">),</span>
            <span class="s">&quot;(&quot;</span><span class="p">:</span> <span class="s">&quot;(&quot;</span><span class="p">,</span>
            <span class="s">&quot;)&quot;</span><span class="p">:</span> <span class="s">&quot;)&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterString</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emptyRes</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_createArgList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterString</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot; ( &quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">,</span> <span class="s">&quot; ) &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid logic string.&quot;</span><span class="p">)</span>
        <span class="c">#self.filter = [self.tokens[x] if x in self.tokens else int(x) for x in s.split()]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">what</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_parens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left_1st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_1st</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left_1st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="nb">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">filter</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_formattedEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">filter</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emptyRes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">has_parens</span><span class="p">,</span> <span class="n">l_paren</span><span class="p">,</span> <span class="n">r_paren</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parens</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_parens</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>

        <span class="nb">filter</span><span class="p">[</span><span class="n">l_paren</span><span class="p">:</span><span class="n">r_paren</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="nb">filter</span><span class="p">[</span><span class="n">l_paren</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r_paren</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emptyRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formattedEval</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">roi</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;g&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;r&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;g&quot;</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;high&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;r&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;g&quot;</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;low&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;r&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;g&quot;</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createArgList</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_formattedEval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">),</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_GRAY2BGR</span><span class="p">)</span>
        <span class="n">image</span><span class="p">[</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">result</span><span class="p">[</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">image</span>



<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An individual image.  Each image is loaded in as its own instance of the Image class for processing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">outputdir</span> <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="n">writename</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dev</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">db</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dbid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param input: The input resource, either a path to an image or a raw numpy array.</span>
<span class="sd">        :type resource: numpy.ndarray or str</span>
<span class="sd">        :param outputdir: The directory to write output files</span>
<span class="sd">        :type outputdir: str</span>
<span class="sd">        :param writename: The name to write the output file as, should include extension.</span>
<span class="sd">        :type writename: str</span>
<span class="sd">        :param dev: Dev mode will do something...</span>
<span class="sd">        :type dev: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputdir</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loadDb</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">dbid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="nb">input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">outputdir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">writename</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writename</span> <span class="o">=</span> <span class="n">writename</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writename</span> <span class="o">=</span> <span class="s">&quot;out.png&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">writename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid output!&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_closeDb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_loadDb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">dbid</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">db</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dbid</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span> <span class="o">=</span> <span class="n">dbid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">check_same_thread</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;select pegasusid from images where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">,))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid pegasusid given!&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;A database id must be provided if you give a database.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid database given!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_addColumn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">tablename</span> <span class="o">=</span> <span class="s">&quot;images&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;PRAGMA table_info(&quot;</span> <span class="o">+</span> <span class="n">tablename</span> <span class="o">+</span> <span class="s">&quot;);&quot;</span><span class="p">)]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;alter table &quot;</span> <span class="o">+</span> <span class="n">tablename</span> <span class="o">+</span> <span class="s">&quot; add column &quot;</span> <span class="o">+</span> <span class="n">column</span> <span class="o">+</span> <span class="s">&quot;;&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span>


    <span class="k">def</span> <span class="nf">_loadROIArg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="p">}</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="s">&quot;-1&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Could not load roi fragment &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="s">&quot;+&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Could not load roi fragment &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="s">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Could not load roi fragment &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="s">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Could not load roi fragment &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_loadROI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param roi: The region of interest to load.</span>
<span class="sd">        :type roi: list or file</span>
<span class="sd">        :return: The region of interest of form [ystart, yend, xstart, xend]</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :raises OSError: if the input path does not exist.</span>

<span class="sd">        Loads a region of interest, either a path to an roi or a raw list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">roi</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_loadROIArg</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rh</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">rh</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;xstart&quot;</span><span class="p">,</span> <span class="s">&quot;xend&quot;</span><span class="p">,</span> <span class="s">&quot;ystart&quot;</span><span class="p">,</span> <span class="s">&quot;yend&quot;</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_loadROIArg</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&quot;ystart&quot;</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROIArg</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&quot;yend&quot;</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROIArg</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&quot;xstart&quot;</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROIArg</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&quot;xend&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Input roi file &#39;</span><span class="si">%s</span><span class="s">&#39; needs xstart, xend, ystart, and yend definitions!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">roi</span><span class="p">,))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">print</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Input roi file &#39;</span><span class="si">%s</span><span class="s">&#39; is not valid json!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">roi</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Input path to roi file &#39;</span><span class="si">%s</span><span class="s">&#39; does not exist!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">roi</span><span class="p">,))</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_writeROI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param roi: The region of interest to write.</span>
<span class="sd">        :type roi: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">output</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">wh</span><span class="p">:</span>
                <span class="n">wh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">&quot;ystart&quot;</span><span class="p">:</span> <span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;yend&quot;</span><span class="p">:</span> <span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;xstart&quot;</span><span class="p">:</span> <span class="n">roi</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;xend&quot;</span><span class="p">:</span> <span class="n">roi</span><span class="p">[</span><span class="mi">3</span><span class="p">]},</span> <span class="n">indent</span> <span class="o">=</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Could not write roi.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_loadBins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param bin: The bin to load</span>
<span class="sd">        :type bin: list or file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binlist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">binlist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">binlist</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">binlist</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rh</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">rh</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Bin list not valid json!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Bin file does not exist.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_loadResource</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resource</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param resource: The resource to load.</span>
<span class="sd">        :type resource: numpy.ndarray or file</span>
<span class="sd">        :return: The image</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        :raises OSError: if the input path does not exist.</span>

<span class="sd">        Loads a resource, either a path to an image or a raw numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="s">&quot;unknown&quot;</span><span class="p">,</span> <span class="n">resource</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resource</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">resource</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">resource</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">resource</span><span class="p">):</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">resource</span><span class="p">),</span> <span class="n">image</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set error =? where pegasusid = ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Load Error, input is not an image.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Input is not an image.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set error = ? where pegasusid = ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Load Error, input path doesn&#39;t exist or specified resource is not a saved state.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Input path to resource does not exist.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_getMergedContour</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assumes that image is already binary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">contours</span><span class="p">,</span><span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cnt</span><span class="p">:</span>
                <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<div class="viewcode-block" id="Image.drawContours"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.drawContours">[docs]</a>    <span class="k">def</span> <span class="nf">drawContours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function that draws all detected contours in the image onto the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">255</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span>
</div>
    <span class="k">def</span> <span class="nf">_colorHistogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list of histograms, corresponding to R, G, B.</span>
<span class="sd">        :rtype: List of numpy arrays.</span>

<span class="sd">        Calculates a normalized colorHistogram of the current image.</span>
<span class="sd">        The intensity is normalized between 0 and 255.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnhist</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">hist_item</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcHist</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">],</span> <span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">])</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">hist_item</span><span class="p">,</span> <span class="n">hist_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">NORM_MINMAX</span><span class="p">)</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">hist_item</span><span class="p">))</span>
            <span class="n">returnhist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">returnhist</span>

    <span class="k">def</span> <span class="nf">_isColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">image</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

<div class="viewcode-block" id="Image.save"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: The name to save the image under.</span>
<span class="sd">        :type name: str OR any hashable type.</span>

<span class="sd">        This function saves the current image in the &#39;states&#39; variable under</span>
<span class="sd">        the specified name.  It can then be reloaded using the :py:meth:`~ih.imgproc.Image.restore`</span>
<span class="sd">        method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.restore"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.restore">[docs]</a>    <span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: The name the image is saved under.</span>
<span class="sd">        :type name: str OR any hashable type.</span>

<span class="sd">        Reloads a previously saved image from the &#39;states&#39; variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Invalid state specified.&quot;</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.list"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.list">[docs]</a>    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lists all saved states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">state</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.destroy"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroys all currently open windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.wait"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.wait">[docs]</a>    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Waits until a key is pressed, then destroys all windows and</span>
<span class="sd">        continues program execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.split"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param channel: The channel to select from the image.</span>
<span class="sd">        :type channel: int</span>

<span class="sd">        This function is a wrapper to the OpenCV function</span>
<span class="sd">        `split &lt;http://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#split&gt;`_.</span>
<span class="sd">        Splits an image into individually channels, and selects a single channel</span>
<span class="sd">        to be the resulting image (Remember, color images have channel order BGR).</span>
<span class="sd">        No validation is done on channel number, so it is possible to provide a</span>
<span class="sd">        channel number that does not exist.  For example, calling split on an</span>
<span class="sd">        bgr image with channel = 2 will extract the red channel from the image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)[</span><span class="n">channel</span><span class="p">]</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.equalizeHist"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.equalizeHist">[docs]</a>    <span class="k">def</span> <span class="nf">equalizeHist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is a wrapper to the OpenCV function</span>
<span class="sd">        `equalizeHist &lt;http://docs.opencv.org/2.4/modules/imgproc/doc/histograms.html#equalizehist&gt;`_.</span>
<span class="sd">        This function equalizes the histogram of a grayscale image by stretching</span>
<span class="sd">        the minimum and maximum values to 0 and 255 respectively.</span>
<span class="sd">        If this is run on a color image it will be converted to gray scale first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.equalizeColor"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.equalizeColor">[docs]</a>    <span class="k">def</span> <span class="nf">equalizeColor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calls the :py:meth:`~ih.imgproc.Image.equalizeHist` function</span>
<span class="sd">        on each individual channel of a color image, and then returns the merged</span>
<span class="sd">        result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.show"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param title: The title to give the display window, if left blank one will be created.</span>
<span class="sd">        :type title: str</span>
<span class="sd">        :return: None</span>

<span class="sd">        Displays the image in a window.  Utilizes the :py:meth:`~ih.imgproc.Image.resize` function.</span>
<span class="sd">        If a title is not specified, the window will be named &#39;windowX&#39; where X is the number of times</span>
<span class="sd">        show has been called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">title</span> <span class="k">if</span> <span class="n">title</span> <span class="k">else</span> <span class="s">&quot;window &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.resizeSelf"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.resizeSelf">[docs]</a>    <span class="k">def</span> <span class="nf">resizeSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param scale: Value to scale image by.</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param width: Target width of image.</span>
<span class="sd">        :type width: int</span>
<span class="sd">        :param height: Target height of image.</span>
<span class="sd">        :type height: int</span>

<span class="sd">        Resizes the current image.  If scale is set, it simply resizes the</span>
<span class="sd">        width and height of the image based on the scale.  If only one of width</span>
<span class="sd">        or height is set, it scales the other accordingly.  If both width</span>
<span class="sd">        and height are set, it scales the image to the exact size specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">or</span> <span class="n">width</span> <span class="ow">or</span> <span class="n">height</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">width</span> <span class="ow">and</span> <span class="n">height</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">width</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">height</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.addWeighted"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.addWeighted">[docs]</a>    <span class="k">def</span> <span class="nf">addWeighted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">weight1</span><span class="p">,</span> <span class="n">weight2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param image: The image to add.</span>
<span class="sd">        :type image: str of np.ndarray</span>
<span class="sd">        :param weight1: The weight to apply to the current image.</span>
<span class="sd">        :type weight1: float</span>
<span class="sd">        :param weight2: The weight to apply to the additional image.</span>
<span class="sd">        :type weight2: float</span>

<span class="sd">        This function is a wrapper to the OpenCV function</span>
<span class="sd">        `addWeighted &lt;http://docs.opencv.org/2.4/modules/core/doc/operations_on_arrays.html#addweighted&gt;`_.</span>
<span class="sd">        This function adds/blends an additional image to the current based on the provided</span>
<span class="sd">        weights.  Both positive and negative weights can be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">addWeighted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">weight1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">image</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.resize"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the image is larger than conf.maxArea, resize its total area down to conf.maxArea.</span>
<span class="sd">        This function is primarily used for viewing purposes, and as such, it does not resize</span>
<span class="sd">        the base image, but creates a copy to resize instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">):</span>
          <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">conf</span><span class="o">.</span><span class="n">maxArea</span><span class="p">):</span>
              <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">conf</span><span class="o">.</span><span class="n">maxArea</span><span class="p">)</span>
              <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">conf</span><span class="o">.</span><span class="n">maxArea</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">conf</span><span class="o">.</span><span class="n">maxArea</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">scale</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">scale</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
</div>
<div class="viewcode-block" id="Image.write"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the current image to the given output directory, with the given name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">writename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writename</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="k">else</span> <span class="n">name</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputdir</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">writename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.convertColor"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.convertColor">[docs]</a>    <span class="k">def</span> <span class="nf">convertColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intype</span><span class="p">,</span> <span class="n">outtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param intype: The input image type</span>
<span class="sd">        :type intype: str</span>
<span class="sd">        :param outtype: The output image type</span>
<span class="sd">        :type outtype: str</span>
<span class="sd">        :return: The converted image.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        :raises: KeyError</span>

<span class="sd">        Converts the given image between color spaces, based on the given types.</span>
<span class="sd">        Supported types are: bgr, gray, hsv, lab, and ycrcb.  Note, you cannot</span>
<span class="sd">        restore color to a gray image with this function, for that you must use</span>
<span class="sd">        bitwise_and with an appropriate mask + image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">intype</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">colors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outtype</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">intype</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">intype</span><span class="p">][</span><span class="n">outtype</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">outtype</span> <span class="o">+</span> <span class="s">&quot; is not a valid output type for the input type: &quot;</span> <span class="o">+</span> <span class="n">intype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">intype</span> <span class="o">+</span> <span class="s">&quot; is not a valid image type.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.threshold"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.threshold">[docs]</a>    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="nb">max</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="s">&quot;binary&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param thresh: Threshold value.</span>
<span class="sd">        :type thresh: int</span>
<span class="sd">        :param max: Write value for binary threshold.</span>
<span class="sd">        :type max: int</span>
<span class="sd">        :param type: Threhsold type.</span>
<span class="sd">        :type type: str</span>
<span class="sd">        :return: The thresholded image.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        :raises KeyError: if the specified threshold type doesn&#39;t exist.</span>

<span class="sd">        Thresholds the image based on the given type.  The image must be</span>
<span class="sd">        grayscale to be thresholded.  If the image is of type &#39;bgr&#39; it is</span>
<span class="sd">        automatically converted to grayscale before thresholding.</span>
<span class="sd">        Supported types are: binary, inverse, truncate, tozero, and otsu.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convertColor</span><span class="p">(</span><span class="s">&quot;bgr&quot;</span><span class="p">,</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">thresholds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">thresholds</span><span class="p">[</span><span class="nb">type</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="nb">type</span> <span class="o">+</span> <span class="s">&quot; is not a valid threshold type.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.rotateColor"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.rotateColor">[docs]</a>    <span class="k">def</span> <span class="nf">rotateColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param color: Color shift to perform.  Should be [b, g, r].</span>
<span class="sd">        :type color: list</span>

<span class="sd">        Shifts the entire color of the image based on the values in</span>
<span class="sd">        the color list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">g</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">color</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.knn"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.knn">[docs]</a>    <span class="k">def</span> <span class="nf">knn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">remove</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param k: Number of nearest neighbors to use</span>
<span class="sd">        :type k: int</span>
<span class="sd">        :param labels: Path to label file.  More info below</span>
<span class="sd">        :type labels: file</span>
<span class="sd">        :param remove: Labels to remove from final image.</span>
<span class="sd">        :type remove: list</span>

<span class="sd">        This function is a wrapper to the OpenCV function `KNearest &lt;http://docs.opencv.org/modules/ml/doc/k_nearest_neighbors.html&gt;`_.</span>
<span class="sd">        The label file should contain training data in json format, using the label name of keys, and all</span>
<span class="sd">        the colors matching that label as an array value.  Each color should be a list of 3 values, in BGR order.</span>
<span class="sd">        That is:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {</span>
<span class="sd">            &quot;plant&quot;: [</span>
<span class="sd">                [234, 125, 100],</span>
<span class="sd">                [100, 100, 100]</span>
<span class="sd">            ],</span>
<span class="sd">            &quot;pot&quot;: [</span>
<span class="sd">                ...</span>
<span class="sd">            }</span>

<span class="sd">        When creating your label file, make sure to use helpful names.  Calling each set of colors &quot;label1&quot;, &quot;label2&quot; e.t.c</span>
<span class="sd">        provides no meaningful information.  The remove list is the list of matched labels to remove from the final image.</span>
<span class="sd">        The names to remove should match the names in your label file exactly. For example, let&#39;s say you have the labels</span>
<span class="sd">        &quot;plant&quot;, &quot;pot&quot;, &quot;track&quot;, and &quot;background&quot; defined, and you only want to keep pixels that match the &quot;plant&quot; label.</span>
<span class="sd">        Your remove list should be specified as [&quot;pot&quot;, &quot;track&quot;, &quot;background&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rh</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">rh</span><span class="p">)</span>
                <span class="n">labelMap</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">trainData</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                     <span class="n">labelMap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                         <span class="n">trainData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                         <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">trainData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                <span class="n">knn</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">KNearest</span><span class="p">()</span>
                <span class="n">knn</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
                <span class="n">fim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">ret</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span><span class="n">fim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">ires</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labelMap</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">])</span>
                <span class="n">final</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ires</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_GRAY2BGR</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Cannot find label file.&quot;</span>
        <span class="k">return</span>

</div>
<div class="viewcode-block" id="Image.kmeans"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.kmeans">[docs]</a>    <span class="k">def</span> <span class="nf">kmeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">attempts</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="s">&quot;random&quot;</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param k: Number of colors in final image.</span>
<span class="sd">        :type k: int</span>
<span class="sd">        :param criteria: Determination of how the algorithm stops execution.  Should be one of &#39;accuracy&#39;, &#39;iteration&#39;, or &#39;either&#39;.</span>
<span class="sd">        :type criteria: str</span>
<span class="sd">        :param maxiter: Maximum number of iterations of the algorithm.</span>
<span class="sd">        :type maxiter: int</span>
<span class="sd">        :param accuracy: Minimum accuracy before algorithm finishes executing.</span>
<span class="sd">        :type accuracy: float</span>
<span class="sd">        :param attempts: Number of times the algorithm is executed using different initial guesses.</span>
<span class="sd">        :type attempts: int</span>
<span class="sd">        :param flags: How to determine initial centers should be either &#39;random&#39; or &#39;pp&#39;.</span>
<span class="sd">        :type flags: str</span>

<span class="sd">        This function is a wrapper to the OpenCV function `kmeans &lt;http://docs.opencv.org/modules/core/doc/clustering.html&gt;`_</span>
<span class="sd">        Adjusts the colors in the image to find the most compact &#39;central&#39; colors.  The amount of colors</span>
<span class="sd">        in the resulting image is the specified value &#39;k&#39;.  The colors are chosen based upon the minimum</span>
<span class="sd">        amount of adjustment in the image necessary.  The criteria parameter determines when the algorithm</span>
<span class="sd">        stops.  If &#39;accuracy&#39; is specified, the algorithm runs until the specified accuracy is reached.  If &#39;iteration&#39;</span>
<span class="sd">        is specified, the algorithm runs the specified number of iterations.  If &#39;either&#39; is specified, the algorithm</span>
<span class="sd">        runs until one of the conditions is satisfied.  The flags parameter determines the initial central colors,</span>
<span class="sd">        and should be either &#39;random&#39; -- to generate a random initial guess -- or &#39;pp&#39; to use center initialization by Arthur and Vassilvitskii.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flags</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">centers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">ktermination</span><span class="p">:</span>
                <span class="n">reshaped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">reshaped</span><span class="p">)</span>
                <span class="n">ret</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">center</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="n">reshaped</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">ktermination</span><span class="p">[</span><span class="n">criteria</span><span class="p">],</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">),</span> <span class="n">attempts</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">centers</span><span class="p">[</span><span class="n">flags</span><span class="p">],</span> <span class="n">bestLabels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">)</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">criteria</span> <span class="o">+</span> <span class="s">&quot; is not a valid termination type.  Should be one of &#39;accuracy&#39;, &#39;iteration&#39;, or &#39;either&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">flags</span> <span class="o">+</span> <span class="s">&quot; is not a valid center type.  Should be either &#39;random&#39; or &#39;pp&#39;.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

</div>
<div class="viewcode-block" id="Image.meanshift"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.meanshift">[docs]</a>    <span class="k">def</span> <span class="nf">meanshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spatial_radius</span><span class="p">,</span> <span class="n">range_radius</span><span class="p">,</span> <span class="n">min_density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param spatial_radius: Spatial Radius</span>
<span class="sd">        :type spatial_radius: int</span>
<span class="sd">        :param range_radius: Range Radius.</span>
<span class="sd">        :type range_radius: int</span>
<span class="sd">        :param min_density: Minimum Density.</span>
<span class="sd">        :type min_density: int</span>
<span class="sd">        :return: The mean-shifted image.</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        Segments the image into clusters based on nearest neighbors.  This function</span>
<span class="sd">        is a wrapper to the `pymeanshift &lt;https://code.google.com/p/pymeanshift/&gt;`_</span>
<span class="sd">        module.  For details on the algorithm itself: `Mean shift: A robust approach toward feature space analysis &lt;http://dx.doi.org/10.1109/34.1000236&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">labels_image</span><span class="p">,</span> <span class="n">number_regions</span><span class="p">)</span> <span class="o">=</span> <span class="n">pms</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">spatial_radius</span> <span class="o">=</span> <span class="n">spatial_radius</span><span class="p">,</span> <span class="n">range_radius</span> <span class="o">=</span> <span class="n">range_radius</span><span class="p">,</span> <span class="n">min_density</span> <span class="o">=</span> <span class="n">min_density</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.adaptiveThreshold"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.adaptiveThreshold">[docs]</a>    <span class="k">def</span> <span class="nf">adaptiveThreshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">adaptiveType</span><span class="p">,</span> <span class="n">thresholdType</span><span class="p">,</span> <span class="n">blockSize</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: Intensity value for the pixels based on the thresholding conditions.</span>
<span class="sd">        :type param: int</span>
<span class="sd">        :param adaptiveType: Adaptive algorithm to use, should be either &#39;mean&#39; or &#39;gaussian&#39;.</span>
<span class="sd">        :type adaptiveType: str</span>
<span class="sd">        :param thresholdType: Threshold type, should be either &#39;binary&#39; or &#39;inverse&#39;.</span>
<span class="sd">        :type thresholdType: str</span>
<span class="sd">        :param blockSize: The window size to consider while thresholding, should only be an odd number.</span>
<span class="sd">        :type blockSize: int</span>
<span class="sd">        :param C: A constant subtracted from the calculated mean in each window.</span>
<span class="sd">        :type C: int</span>

<span class="sd">        Thresholds an image by considering the image in several different windows instead of the image</span>
<span class="sd">        as a whole.  This function is a wrapper to the OpenCV function `adaptiveThreshold &lt;http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold&gt;`_.</span>
<span class="sd">        Specifying &#39;mean&#39; for adaptiveType calculates a simple mean of the area, wheras specifying &#39;gaussian&#39; calculates a weighted sum</span>
<span class="sd">        based upon a `Gaussian Kernel &lt;http://docs.opencv.org/modules/imgproc/doc/filtering.html#Mat getGaussianKernel(int ksize, double sigma, int ktype)&gt;`_.</span>
<span class="sd">        Specifying &#39;binary&#39; for thresholdType means that a particular intensity value must beat the threshold to be kept, whereas</span>
<span class="sd">        specifying &#39;inverse&#39; means that a particular intensity value must lose to the threshold to be kept.</span>
<span class="sd">        Similar to a normal thresholding function, the image must be converted to grayscale first.  This can be done using the</span>
<span class="sd">        :meth:`~ih.imgproc.Image.convertColor` function, however, if your image is of type &#39;bgr&#39;, this is handled automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convertColor</span><span class="p">(</span><span class="s">&quot;bgr&quot;</span><span class="p">,</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adaptiveType</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">adaptives</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">thresholdType</span> <span class="o">==</span> <span class="s">&quot;binary&quot;</span> <span class="ow">or</span> <span class="n">thresholdType</span> <span class="o">==</span> <span class="s">&quot;inverse&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">adaptiveThreshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">adaptives</span><span class="p">[</span><span class="n">adaptiveType</span><span class="p">],</span> <span class="n">conf</span><span class="o">.</span><span class="n">thresholds</span><span class="p">[</span><span class="n">thresholdType</span><span class="p">],</span> <span class="n">blockSize</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Threshold type: &quot;</span> <span class="o">+</span> <span class="n">thresholdType</span> <span class="o">+</span> <span class="s">&quot; must be either binary or inverse.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Adaptive type: &quot;</span> <span class="o">+</span> <span class="n">adaptiveType</span> <span class="o">+</span> <span class="s">&quot; is not a valid adaptive threshold type, should be either &#39;mean&#39; or &#39;gaussian&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.blur"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.blur">[docs]</a>    <span class="k">def</span> <span class="nf">blur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">borderType</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ksize: The size of the kernel represented by a tuple (width, height).  Both numbers should be odd and positive.</span>
<span class="sd">        :type ksize: tuple</span>
<span class="sd">        :param anchor: The anchor point for filtering.  Default is (-1, -1) which is the center of the kernel.</span>
<span class="sd">        :type anchor: tuple</span>
<span class="sd">        :param borderType: The type of border mode used to extrapolate pixels outside the image.</span>
<span class="sd">        :type borderType: str</span>

<span class="sd">        Smoothes an image using the normalized box filter.  This function is a wrapper to the OpenCV function</span>
<span class="sd">        `blur &lt;http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur&gt;`_.  Increasing the kernel size increase</span>
<span class="sd">        the window considered when applying a blur.  The anchor by default is the center of the kernel,</span>
<span class="sd">        however you can alter the anchor to consider different areas of the kernel.  When blurring on the edge</span>
<span class="sd">        of the image, values for pixels that would be outside of the image are extrapolated.  The method</span>
<span class="sd">        of extrapolation depends on the specified &#39;borderType&#39;, and can be one of &#39;default&#39;, &#39;constant&#39;,</span>
<span class="sd">        &#39;reflect&#39;, or &#39;replicate&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">borderType</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">blur</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="n">borderType</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid border type, should be one of: &quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.medianBlur"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.medianBlur">[docs]</a>    <span class="k">def</span> <span class="nf">medianBlur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ksize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ksize: The size of the kernel (ksize x ksize).  Should be odd and positive.</span>
<span class="sd">        :type ksize: int</span>

<span class="sd">        This function smoothes an image using the median filter.  The kernel is set to size (ksize, ksize).</span>
<span class="sd">        The anchor position is assumed to be the center.  This function is a wrapper to the opencv function</span>
<span class="sd">        `medianBlur &lt;http://docs.opencv.org/modules/imgproc/doc/filtering.html#medianBlur&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">medianBlur</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">ksize</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.gaussianBlur"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.gaussianBlur">[docs]</a>    <span class="k">def</span> <span class="nf">gaussianBlur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">sigmaX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigmaY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">borderType</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ksize: The size of the kernel represented by a tuple (width, height).  Both numers should be odd and positive.</span>
<span class="sd">        :type ksize: tuple</span>
<span class="sd">        :param sigmaX: The standard deviation in the x direction.  If 0, the value is calculated based on the kernel size.</span>
<span class="sd">        :type sigmaX: float</span>
<span class="sd">        :param sigmaY: The standard deviation in the y direction.  If 0, the value is equal to sigmaX.</span>
<span class="sd">        :type sigmaY: float</span>
<span class="sd">        :param borderType: The type of border mode used to extrapolate pixels outside the image.</span>
<span class="sd">        :type borderType: str</span>

<span class="sd">        This function blurs an image based on a Gaussian kernel.  When blurring on the edge</span>
<span class="sd">        of the image, values for pixels that would be outside of the image are extrapolated.  The method</span>
<span class="sd">        of extrapolation depends on the specified &#39;borderType&#39;, and can be one of &#39;default&#39;, &#39;constant&#39;,</span>
<span class="sd">        &#39;reflect&#39;, or &#39;replicate&#39;.  This function is a wrapper to the OpenCV function `GaussianBlur &lt;http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">borderType</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">:</span>
            <span class="n">sigmaY</span> <span class="o">=</span> <span class="n">sigmaX</span> <span class="k">if</span> <span class="n">sigmaY</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">sigmaY</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
            <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span> <span class="o">=</span> <span class="n">roi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ystart</span><span class="p">:</span><span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">:</span><span class="n">xend</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ystart</span><span class="p">:</span><span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">:</span><span class="n">xend</span><span class="p">],</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">sigmaX</span><span class="p">,</span> <span class="n">sigmaY</span><span class="p">,</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="n">borderType</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid border type, should be one of: &quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.normalizeByIntensity"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.normalizeByIntensity">[docs]</a>    <span class="k">def</span> <span class="nf">normalizeByIntensity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes each channel of the pixel by its intensity.  For each pixel, the intensity is defined as</span>
<span class="sd">        :math:`I = R + G + B`, where :math:`R,G,B` are the color values for that pixel.  We calculate new color values by</span>
<span class="sd">        multiplying the original number by 255, and dividing by the intensity, that is, :math:`r = \\frac{255 \\cdot R}{I}</span>
<span class="sd">        , g = \\frac{255 \\cdot G}{I}, b = \\frac{255 \\cdot B}{I}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">f</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">255</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">scaled</span><span class="p">,</span> <span class="n">combined</span><span class="p">[:,:,</span><span class="bp">None</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.morphology"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.morphology">[docs]</a>    <span class="k">def</span> <span class="nf">morphology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morphType</span><span class="p">,</span> <span class="n">ktype</span><span class="p">,</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">borderType</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param morphType: The type of morphology to perform.  Should be dilate, erode, open, close, gradient, tophat, or blackhat.</span>
<span class="sd">        :type morphType: str</span>
<span class="sd">        :param ktype: the type of the kernel, should be rect, ellipse, or cross.</span>
<span class="sd">        :type ktype: str</span>
<span class="sd">        :param ksize: The size of the kernel represented by a tuple (width, height).  Both numbers should be odd and positive.</span>
<span class="sd">        :type ksize: tuple</span>
<span class="sd">        :param anchor: The anchor point for filtering.  Default is (-1, -1) which is the center of the kernel.</span>
<span class="sd">        :type anchor: tuple</span>
<span class="sd">        :param iterations: The number of times to perform the specified morphology.</span>
<span class="sd">        :type iterations: int</span>
<span class="sd">        :param borderType: The type of border mode used to extrapolate pixels outside the image.</span>
<span class="sd">        :type borderType: str</span>

<span class="sd">        This function performs morphological operations based on the inputted values. This function is</span>
<span class="sd">        a wrapper to the OpenCv function `morphologyEx &lt;http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex&gt;`_. When performing the morphology on the edges</span>
<span class="sd">        of the image, values for pixels that would be outside of the image are extrapolated.  The method</span>
<span class="sd">        of extrapolation depends on the specified &#39;borderType&#39;, and can be one of &#39;default&#39;, &#39;constant&#39;,</span>
<span class="sd">        &#39;reflect&#39;, or &#39;replicate&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">morphType</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">morph</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ktype</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">kernels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">borderType</span> <span class="ow">in</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">:</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getStructuringElement</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">kernels</span><span class="p">[</span><span class="n">ktype</span><span class="p">],</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">anchor</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">morphologyEx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">morph</span><span class="p">[</span><span class="n">morphType</span><span class="p">],</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">anchor</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="p">[</span><span class="n">borderType</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid border type, should be one of: &quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">borders</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid kernel type, should be one of: &quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid morphology type, should be one of: &quot;</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">morph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_findSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seedMask</span><span class="p">):</span>
        <span class="n">bname</span><span class="p">,</span> <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">seedMask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">(</span><span class="n">binary</span><span class="p">):</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">select</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">select</span> <span class="o">=</span> <span class="n">cnt</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<div class="viewcode-block" id="Image.floodFill"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.floodFill">[docs]</a>    <span class="k">def</span> <span class="nf">floodFill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">writeColor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">connectivity</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fixed</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">findSeed</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">seedMask</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">binary</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param mask: A binary image corresponding to the area you don&#39;t want to fill.</span>
<span class="sd">        :type mask: str or np.ndarray</span>
<span class="sd">        :param seed: The beginning point to use for filling.</span>
<span class="sd">        :type seed: Tuple (x, y)</span>
<span class="sd">        :param low: Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</span>
<span class="sd">        :type low: Tuple (b, g, r) or (i,)</span>
<span class="sd">        :param high: Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</span>
<span class="sd">        :type high: Tuple (b, g, r) or (i,)</span>
<span class="sd">        :param writeColor: The color to write to the filled region.  Default (255, 255, 255).</span>
<span class="sd">        :type writeColor: tuple (b, g, r) or (i,)</span>
<span class="sd">        :param connectivity: The number of neighboring pixels to consider for the flooding operation.  Should be 4 or 8.</span>
<span class="sd">        :type connectivity: int</span>
<span class="sd">        :param fixed: If True, calculates color differences relative to the seed.</span>
<span class="sd">        :type fixed: boolean</span>
<span class="sd">        :param findSeed: If True, picks a seed point based on contours in the seedMask image.</span>
<span class="sd">        :type findSeed: boolean</span>
<span class="sd">        :param seedMask: Binary image to select seed from.</span>
<span class="sd">        :type seedMask: str or np.ndarray</span>
<span class="sd">        :param binary: Specify if input image is binary.</span>
<span class="sd">        :type binary: boolean</span>

<span class="sd">        This function is a wrapper to the OpenCV function `floodFill &lt;http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html#floodfill&gt;`_.</span>
<span class="sd">        This function floods the region of an image based on calculated color differences from neighbors or from the seed.  When flooding a binary</span>
<span class="sd">        image all input color tuples should have 1 value instead of 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">writeColor</span>
        <span class="n">mname</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convertColor</span><span class="p">(</span><span class="s">&quot;bgr&quot;</span><span class="p">,</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
        <span class="c"># Mask is required to be 2 pixels wider and taller than the image</span>
        <span class="n">adjmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">adjmask</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">writeColor</span><span class="p">)</span> <span class="o">==</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">connectivity</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">findSeed</span> <span class="ow">and</span> <span class="n">seedMask</span><span class="p">:</span>
                            <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findSeed</span><span class="p">(</span><span class="n">seedMask</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">fixed</span><span class="p">:</span>
                            <span class="n">cv2</span><span class="o">.</span><span class="n">floodFill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">adjmask</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">writeColor</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">connectivity</span> <span class="o">|</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FLOODFILL_FIXED_RANGE</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cv2</span><span class="o">.</span><span class="n">floodFill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">adjmask</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">writeColor</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid value for connectivity, should be either 4 or 8.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Incorrect number of values for write color.  Number of values should match input image channels (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">channels</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Incorrect number of values for high difference.  Number of values should match input image channels (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">channels</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Incorrect number of values for low difference.  Number of values should match input image channels (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">channels</span><span class="p">,))</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.fill"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param roi: A list corresponding to the area of the image you want.  List should be of the form [ystart, yend, xstart, xend]</span>
<span class="sd">        :type roi: list or roi file</span>
<span class="sd">        :param color: A list corresponding to BGR values to fill the corresponding area with.</span>
<span class="sd">        :type color: list</span>

<span class="sd">        Fills the given roi with the given color.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span> <span class="o">=</span> <span class="n">roi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ystart</span><span class="p">:</span><span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">:</span><span class="n">xend</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
        <span class="k">return</span>


</div>
<div class="viewcode-block" id="Image.crop"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">,</span> <span class="n">resize</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param roi: A list corresponding to the area of the image you want.  List should be of the form [ystart, yend, xstart, xend]</span>
<span class="sd">        :type roi: list or roi file</span>
<span class="sd">        :param resize: If True, actually adjusts the size of the image, otherwise just draws over the part of the image not in the roi.</span>
<span class="sd">        :type resize: bool</span>

<span class="sd">        This function crops the image based on the given roi [ystart, yend, xstart, xend].  There are two crop options,</span>
<span class="sd">        by default, the function doesn&#39;t actually resize the image.  Instead, it sets each pixel not in the roi to black.</span>
<span class="sd">        If resize is set to True, the function will actually crop the image down to the roi.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span> <span class="o">=</span> <span class="n">roi</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">resize</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ystart</span><span class="p">:</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">:</span> <span class="n">xend</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
            <span class="n">off</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">()</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ystart</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">maxx</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">yend</span><span class="p">:</span><span class="n">maxy</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">maxx</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxy</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">xstart</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxy</span><span class="p">,</span> <span class="n">xend</span><span class="p">:</span><span class="n">maxx</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.mask"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function convers the image to a color mask by performing the following operations:</span>

<span class="sd">        1. convertColor(&quot;bgr&quot;, &quot;gray&quot;)</span>
<span class="sd">        2. threshold(0)</span>
<span class="sd">        3. convertColor(&quot;gray&quot;, &quot;bgr&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertColor</span><span class="p">(</span><span class="s">&quot;bgr&quot;</span><span class="p">,</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertColor</span><span class="p">(</span><span class="s">&quot;gray&quot;</span><span class="p">,</span> <span class="s">&quot;bgr&quot;</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.contourChop"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.contourChop">[docs]</a>    <span class="k">def</span> <span class="nf">contourChop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">basemin</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param binary: The binary image to find contours of.</span>
<span class="sd">        :type binary: str of np.ndarray</span>
<span class="sd">        :param basemin: The minimum area a contour must have to be considered part of the foreground.</span>
<span class="sd">        :type basemin: int</span>

<span class="sd">        This function works very similiarly to the :py:meth:`~ih.imgproc.Image.contourCut`</span>
<span class="sd">        function, except that this function does not crop the image, but removes</span>
<span class="sd">        all contours that fall below the threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bname</span><span class="p">,</span> <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">(</span><span class="n">binary</span><span class="p">):</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_EXTERNAL</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">basemin</span><span class="p">):</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="n">cnt</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.getBounds"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.getBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The bounding box of the image.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        This function finds the bounding box of all contours in the image, and</span>
<span class="sd">        returns a list of the form [miny, maxy, minx, maxx]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">(</span><span class="n">binary</span><span class="p">):</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_TREE</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boundingRect</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">):</span>
                <span class="n">minx</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">miny</span><span class="p">):</span>
                <span class="n">miny</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">):</span>
                <span class="n">maxx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">):</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Image.contourCut"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.contourCut">[docs]</a>    <span class="k">def</span> <span class="nf">contourCut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binary</span><span class="p">,</span> <span class="n">basemin</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">resize</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">returnBound</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">roiwrite</span> <span class="o">=</span> <span class="s">&quot;roi.json&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param binary: The binary image to find contours of.</span>
<span class="sd">        :type binary: str or np.ndarray</span>
<span class="sd">        :param basemin: The minimum area a contour must have to be considered part of the foreground.</span>
<span class="sd">        :type basemin: int</span>
<span class="sd">        :param padding: Padding add to all sides of the final roi.</span>
<span class="sd">        :type padding: int</span>
<span class="sd">        :param returnBound: If set, instead of cropping the image, simply write the detected roi.</span>
<span class="sd">        :type returnBound: bool</span>
<span class="sd">        :param resize: Whether or not to resize the image.</span>
<span class="sd">        :type resize: bool</span>

<span class="sd">        This function crops an image based on the size of detected contours in the image --</span>
<span class="sd">        clusters of pixels in the image.  The image is cropped such that all contours</span>
<span class="sd">        that are greater than the specified area are included in the final output image.</span>
<span class="sd">        image is cropped such that all contours that are greater than the specified area are</span>
<span class="sd">        included in the final output image.  If returnBound is set, instead of actually</span>
<span class="sd">        cropping the image, the detected roi is written to a file instead.  Otherwise,</span>
<span class="sd">        the detected roi is passed into the :py:meth:`~ih.imgproc.Image.crop` function,</span>
<span class="sd">        with the given resize value.  This function is useful for getting accurate</span>
<span class="sd">        height and width of a specific plant, as well as removing outlying clusters</span>
<span class="sd">        of non-important pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bname</span><span class="p">,</span> <span class="n">binary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isColor</span><span class="p">(</span><span class="n">binary</span><span class="p">):</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findContours</span><span class="p">(</span><span class="n">binary</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">RETR_TREE</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CHAIN_APPROX_SIMPLE</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">boundingRect</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">basemin</span> <span class="o">&lt;</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span><span class="n">cnt</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minx</span><span class="p">):</span>
                    <span class="n">minx</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">miny</span><span class="p">):</span>
                    <span class="n">miny</span> <span class="o">=</span> <span class="n">y</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">maxx</span><span class="p">):</span>
                    <span class="n">maxx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">maxy</span><span class="p">):</span>
                    <span class="n">maxy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">h</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">miny</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">miny</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">maxy</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">maxy</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">minx</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">minx</span> <span class="o">-</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">maxx</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">maxx</span> <span class="o">+</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">returnBound</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_writeROI</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">roiwrite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">resize</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.edges"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold1</span><span class="p">,</span> <span class="n">threshold2</span><span class="p">,</span> <span class="n">apertureSize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">L2gradient</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param threshold1: First threshold for the hysteresis procedure.</span>
<span class="sd">        :type threshold1: int</span>
<span class="sd">        :param threshold2: Second threshold for the hysteresis procedure.</span>
<span class="sd">        :type threshold2: int</span>
<span class="sd">        :param apertureSize: aperture size used for the Sobel operator.  Must be odd, postive, and less than 8.</span>
<span class="sd">        :type apertureSize: int</span>
<span class="sd">        :L2gradient: Used to calculate Image gradient magnitude, if true then :math:`L = \sqrt{(dI/dx)^2 + (dI/dy)^2}`, if false then :math:`L = dI/dx + dI/dy`.</span>
<span class="sd">        :type L2gradient: bool</span>

<span class="sd">        This function calculates the edges of an image using the Canny edge detection algorithm using the Sobel operator.  This function is a wrapper to the OpenCV function `Canny &lt;http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#canny&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold1</span><span class="p">,</span> <span class="n">threshold2</span><span class="p">,</span> <span class="n">apertureSize</span> <span class="o">=</span> <span class="n">apertureSize</span><span class="p">,</span> <span class="n">L2gradient</span> <span class="o">=</span> <span class="n">L2gradient</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.colorFilter"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.colorFilter">[docs]</a>    <span class="k">def</span> <span class="nf">colorFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logic</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param logic: The logic you want to run on the image.</span>
<span class="sd">        :type logic: str</span>
<span class="sd">        :param roi: The roi you want to apply the filter to</span>
<span class="sd">        :type roi: list or roi file</span>

<span class="sd">        This function applies a color filter defined by the input logic, to a</span>
<span class="sd">        targeted region defined by the input roi. The logic string itself is fairly complicated.</span>
<span class="sd">        The string supports the following characters: &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;,</span>
<span class="sd">        &#39;==&#39;, &#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;and&#39;, &#39;or&#39;, &#39;(&#39;, &#39;)&#39;, &#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;max&#39;, and &#39;min&#39; as well as any numeric</span>
<span class="sd">        value.  The logic string itself must be well formed -- each</span>
<span class="sd">        operation, arg1 operator arg2, must be surrounded by parenthesis, and the entire statement</span>
<span class="sd">        must be surrounded by parenthesis.  For example,</span>
<span class="sd">        if you want to check the intensity of the pixel, your logic string would be:</span>
<span class="sd">        &#39;(((r + g) + b) &lt; 100)&#39;.  This string in particular will only keep pixels whose</span>
<span class="sd">        intensity is less than 100.  Similar rules apply for &#39;and&#39; and &#39;or&#39; operators.</span>
<span class="sd">        Let&#39;s say we only want to keep pixels whose intensity is less than 100, OR both</span>
<span class="sd">        the red and blue channels are greater than 150, the logic string would be:</span>
<span class="sd">        &#39;((((r + g) + b) &lt; 100) or ((r &gt; 150) and (b &gt; 150)))&#39;.  The more complex</span>
<span class="sd">        your logic is the harder it is to read, so you may want to consider breaking</span>
<span class="sd">        up complex filtering into multiple steps for readability.  Finally, despite</span>
<span class="sd">        the fact this function solves arbitrary logic, it is very fast.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="n">ColorFilter</span><span class="p">(</span><span class="n">logic</span><span class="p">)</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">filter</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">roi</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.bitwise_not"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.bitwise_not">[docs]</a>    <span class="k">def</span> <span class="nf">bitwise_not</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverts the image.  If the given image has multiple channels (i.e. is a color image) each channel is processed independently.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.bitwise_and"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.bitwise_and">[docs]</a>    <span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param comp: The comparison image.</span>
<span class="sd">        :type comp: str or np.ndarray</span>
<span class="sd">        :return: The resulting mask.</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        Performs logical AND between the input image and the comp image.</span>
<span class="sd">        The comp input is very versatile, and can be one of three input types,</span>
<span class="sd">        an image, a path, or a saved state.  An image input is a raw numpy array,</span>
<span class="sd">        and this input type will be passed through to the function without modification.</span>
<span class="sd">        If a path is specified, ih attempts to load the file as an image, and pass it</span>
<span class="sd">        to the function.  Finally, the input is checked against the currently saved</span>
<span class="sd">        image states.  If it matches, the corresponding state is passed to the function.</span>
<span class="sd">        The function assumes that the two input images are of matching type --</span>
<span class="sd">        if they are not an error will be thrown.  By default, images loaded from a</span>
<span class="sd">        path are loaded as &#39;bgr&#39; type images.</span>
<span class="sd">        For more information on states, see :py:meth:`~ih.imgproc.Image.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">comp</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.bitwise_or"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.bitwise_or">[docs]</a>    <span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param comp: The comparison image.</span>
<span class="sd">        :type comp: str or np.ndarray</span>
<span class="sd">        :return: The resulting mask.</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        Performs logical OR between the input image and the comp image.</span>
<span class="sd">        The comp input is very versatile, and can be one of three input types,</span>
<span class="sd">        an image, a path, or a saved state.  An image input is a raw numpy array,</span>
<span class="sd">        and this input type will be passed through to the function without modification.</span>
<span class="sd">        If a path is specified, ih attempts to load the file as an image, and pass it</span>
<span class="sd">        to the function.  Finally, the input is checked against the currently saved</span>
<span class="sd">        image states.  If it matches, the corresponding state is passed to the function.</span>
<span class="sd">        The function assumes that the two input images are of matching type --</span>
<span class="sd">        if they are not an error will be thrown.  By default, images loaded from a</span>
<span class="sd">        path are loaded as &#39;bgr&#39; type images.</span>
<span class="sd">        For more information on states, see :py:meth:`~ih.imgproc.Image.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">comp</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.bitwise_xor"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.bitwise_xor">[docs]</a>    <span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param comp: The comparison image.</span>
<span class="sd">        :type comp: str or np.ndarray</span>
<span class="sd">        :return: The resulting mask.</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        Performs exclusive logical OR between the input image and the comp image.</span>
<span class="sd">        The comp input is very versatile, and can be one of three input types,</span>
<span class="sd">        an image, a path, or a saved state.  An image input is a raw numpy array,</span>
<span class="sd">        and this input type will be passed through to the function without modification.</span>
<span class="sd">        If a path is specified, ih attempts to load the file as an image, and pass it</span>
<span class="sd">        to the function.  Finally, the input is checked against the currently saved</span>
<span class="sd">        image states.  If it matches, the corresponding state is passed to the function.</span>
<span class="sd">        The function assumes that the two input images are of matching type --</span>
<span class="sd">        if they are not an error will be thrown.  By default, images loaded from a</span>
<span class="sd">        path are loaded as &#39;bgr&#39; type images.</span>
<span class="sd">        For more information on states, see :py:meth:`~ih.imgproc.Image.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadResource</span><span class="p">(</span><span class="n">comp</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.extractLabels"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractLabels">[docs]</a>    <span class="k">def</span> <span class="nf">extractLabels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">meta_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param fname: The output file name to write.</span>
<span class="sd">        :type fname: str</span>
<span class="sd">        :param meta_labels: A dictionary containing required meta info.</span>
<span class="sd">        :type meta_labels: dict</span>

<span class="sd">        Meta labels should look like:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            meta_labels {</span>
<span class="sd">                &quot;label_name&quot;: roi,</span>
<span class="sd">                &quot;label_name2&quot;: roi</span>
<span class="sd">            }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">labelname</span> <span class="ow">in</span> <span class="n">meta_labels</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">meta_labels</span><span class="p">[</span><span class="n">labelname</span><span class="p">])</span>
            <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span> <span class="o">=</span> <span class="n">roi</span>
            <span class="n">data</span><span class="p">[</span><span class="n">labelname</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">ystart</span><span class="p">:</span> <span class="n">yend</span><span class="p">,</span> <span class="n">xstart</span><span class="p">:</span> <span class="n">xend</span><span class="p">],</span> <span class="p">((</span><span class="n">yend</span> <span class="o">-</span> <span class="n">ystart</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xend</span> <span class="o">-</span> <span class="n">xstart</span><span class="p">),</span> <span class="mi">3</span><span class="p">))]</span>
        <span class="k">print</span> <span class="n">data</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">wh</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wh</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.extractFinalPath"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractFinalPath">[docs]</a>    <span class="k">def</span> <span class="nf">extractFinalPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function writes the absolute path of the output file to the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
             <span class="n">finalpath</span> <span class="o">=</span> <span class="s">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:])</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;outputPath&quot;</span><span class="p">)</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set outputPath=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">finalpath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Image.extractMoments"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractMoments">[docs]</a>    <span class="k">def</span> <span class="nf">extractMoments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A dictionary corresponding to the different moments of the image.</span>
<span class="sd">        :rtype: dict</span>

<span class="sd">        Calculates the moments of the image, and returns a dicitonary based on them.</span>
<span class="sd">        Spatial moments are prefixed with &#39;m&#39;, central moments are prefixed with &#39;mu&#39;,</span>
<span class="sd">        and central normalized moments are prefixed with &#39;nu&#39;.  This function</span>
<span class="sd">        is a wrapper to the OpenCV function `moments &lt;http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#moments&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set &quot;</span> <span class="o">+</span> <span class="nb">id</span> <span class="o">+</span> <span class="s">&quot;=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="nb">id</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">moments</span>
</div>
<div class="viewcode-block" id="Image.extractDimsFromROI"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractDimsFromROI">[docs]</a>    <span class="k">def</span> <span class="nf">extractDimsFromROI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param roi: The roi to calculate height from.</span>
<span class="sd">        :type roi: list or roi file</span>

<span class="sd">        :return: A list corresponding to the calculated height and width of the image.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        Returns a list with the follwoing form: [height, width].  This functions differs</span>
<span class="sd">        from the :py:meth:`~ih.imgproc.Image.extractDimensions` in the way that height</span>
<span class="sd">        is calculated.  Rather than calculating the total height of the image,</span>
<span class="sd">        the height is calculated from the top of the given ROI.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadROI</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="n">plant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">pot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">plant</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">plant</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">plant</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;width&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set height=?,width=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="Image.extractDimensions"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">extractDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list corresponding to the height and width of the image.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        Returns a list with the following form: [height, width]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBounds</span><span class="p">()</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;width&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set height=?,width=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Image.extractMinEnclosingCircle"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractMinEnclosingCircle">[docs]</a>    <span class="k">def</span> <span class="nf">extractMinEnclosingCircle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The center, and radius of the minimum enclosing circle.</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Returns the center and radius of the minimum enclosing circle of all</span>
<span class="sd">        non-black pixels in the image.  The point of this function</span>
<span class="sd">        is not to threshold, so the contours are generated from</span>
<span class="sd">        all the pixels that fall into the range [1, 1, 1], [255, 255, 255].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minEnclosingCircle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getMergedContour</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;circle_centerx&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;circle_centery&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;circle_radius&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set circle_centerx=?, circle_centery=?, circle_radius=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">circle</span>
</div>
<div class="viewcode-block" id="Image.extractConvexHull"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractConvexHull">[docs]</a>    <span class="k">def</span> <span class="nf">extractConvexHull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The area of the convex hull.</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Returns the area of the convex hull around all non black pixels in the image.</span>
<span class="sd">        The point of this function is not to threshold, so the contours are generate from</span>
<span class="sd">        all the pixels that fall into the range [1, 1, 1], [255, 255, 255]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">contourArea</span><span class="p">(</span>
                 <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">convexHull</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_getMergedContour</span><span class="p">()</span>
                    <span class="p">),</span> <span class="mf">0.001</span><span class="p">,</span> <span class="bp">True</span>
                <span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;convex_hull_area&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set convex_hull_area=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hull</span>
</div>
<div class="viewcode-block" id="Image.extractPixels"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractPixels">[docs]</a>    <span class="k">def</span> <span class="nf">extractPixels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The number of non-black pixels in the image.</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Returns the number of non-black pixels in the image.  Creates</span>
<span class="sd">        a temporary binary image to do this.  The point of this function</span>
<span class="sd">        is not to threshold, so the binary image is created by all</span>
<span class="sd">        pixels that fall into the range [1, 1, 1], [255, 255, 255].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pixelCount</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">countNonZero</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;pixels&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set pixels=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pixelCount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pixelCount</span>
</div>
<div class="viewcode-block" id="Image.extractColorData"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractColorData">[docs]</a>    <span class="k">def</span> <span class="nf">extractColorData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonzero</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">returnhist</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param nonzero: Whether or not to look at only nonzero pixels.  Default true.</span>
<span class="sd">        :type nonzero: bool</span>
<span class="sd">        :return: Mean &amp; median for each channel.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        This function calculates a normalized histogram of each individual color channel of</span>
<span class="sd">        the image, and returns the mean &amp; median of the histograms for the channels</span>
<span class="sd">        specified.  Because images are imported with the channels ordered as B,G,R,</span>
<span class="sd">        the output list is returned the same way.  The returned list always looks like</span>
<span class="sd">        this: [ [BlueMean, BlueMedian], [GreenMean, GreenMedian], [RedMean, RedMedian] ].</span>
<span class="sd">        Mean values always come before median values.  If nonzero is set to true (default)</span>
<span class="sd">        the function will only calculate mediapytn and means based on the non-black pixels.</span>
<span class="sd">        If you are connected to a database, the entire histogram is saved to the database,</span>
<span class="sd">        not just the mean and median.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_colorHistogram</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">returnhist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hist</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span>    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="k">if</span> <span class="n">nonzero</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;rmean&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;rmed&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;gmean&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;gmed&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;bmean&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="s">&quot;bmed&quot;</span><span class="p">)</span>
            <span class="n">query</span> <span class="o">=</span> <span class="s">&quot;update images set rmean=?,rmed=?,gmean=?,gmed=?,bmean=?,bmed=?&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&quot;bhist&quot;</span><span class="p">,</span> <span class="s">&quot;ghist&quot;</span><span class="p">,</span> <span class="s">&quot;rhist&quot;</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">query</span> <span class="o">+=</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;=?&quot;</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">query</span> <span class="o">+=</span> <span class="s">&quot; where pegasusid=?&quot;</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">colors</span>
</div>
<div class="viewcode-block" id="Image.extractColorChannels"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractColorChannels">[docs]</a>    <span class="k">def</span> <span class="nf">extractColorChannels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    	This function extracts the total number of pixels of each color value</span>
<span class="sd">        for each channel.</span>
<span class="sd">    	&quot;&quot;&quot;</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">gdata</span><span class="p">,</span> <span class="n">rdata</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
            <span class="n">bdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)))</span>
            <span class="n">gdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)))</span>
            <span class="n">rdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">bdata</span><span class="p">,</span> <span class="n">gdata</span><span class="p">,</span> <span class="n">rdata</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="s">&quot;update images set &quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="s">&quot;b&quot;</span><span class="p">:</span>
                        <span class="n">query</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;=?&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">query</span> <span class="o">+=</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;=?&quot;</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">query</span> <span class="o">+=</span> <span class="s">&quot; where pegasusid=?&quot;</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">gdata</span><span class="p">,</span> <span class="n">rdata</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Image.extractBins"><a class="viewcode-back" href="../../processing.html#ih.imgproc.Image.extractBins">[docs]</a>    <span class="k">def</span> <span class="nf">extractBins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param binlist: The specified bins (color ranges) to count.</span>
<span class="sd">        :type binlist: list</span>
<span class="sd">        :return: The number of pixels that fall in each bin.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        This function counts the number of pixels that fall into the range as</span>
<span class="sd">        specified by each bin.  This function expects the input to be a list of</span>
<span class="sd">        dictionaries as follows:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">             binlist = [</span>
<span class="sd">                {&quot;name&quot;: &quot;bin1&quot;,</span>
<span class="sd">                 &quot;min&quot;: [B, G, R],</span>
<span class="sd">                 &quot;max&quot;: [B, G, R]</span>
<span class="sd">                },</span>
<span class="sd">                {&quot;name&quot;: &quot;bin2&quot;,</span>
<span class="sd">                ...</span>
<span class="sd">            ]</span>

<span class="sd">        Each range is defined by 6 values.  A minimum and maximum blue,</span>
<span class="sd">        green, and red value. The returned list is very similar to the</span>
<span class="sd">        input list, except a &#39;count&#39; key is added to each dictionary:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            returnlist = [</span>
<span class="sd">                {&quot;name&quot;: &quot;bin1&quot;,</span>
<span class="sd">                &quot;min&quot;: [B, G, R],</span>
<span class="sd">                &quot;max&quot;: [B, G, R],</span>
<span class="sd">                &quot;count&quot;: VALUE</span>
<span class="sd">                },</span>
<span class="sd">                ...</span>
<span class="sd">            ]</span>

<span class="sd">        Where &#39;VALUE&#39; is the number of pixels that fall into the</span>
<span class="sd">        corresponding range.</span>
<span class="sd">        A list is used instead of a dictionary as the base structure</span>
<span class="sd">        to maintain order for writing to the output database.  When</span>
<span class="sd">        using this function within a workflow, the order you specify</span>
<span class="sd">        your bins is the order in which they will show up in the</span>
<span class="sd">        database, and the name you specify for you bin will be</span>
<span class="sd">        the column name in the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">binlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loadBins</span><span class="p">(</span><span class="n">binlist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">binlist</span><span class="p">)):</span>
            <span class="n">binlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">countNonZero</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">inRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">binlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&quot;min&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">binlist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&quot;max&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="n">binlist</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addColumn</span><span class="p">(</span><span class="nb">bin</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;update images set &quot;</span> <span class="o">+</span> <span class="nb">bin</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;=? where pegasusid=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">bin</span><span class="p">[</span><span class="s">&quot;count&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">binlist</span></div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2015, Avi Knecht.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3a0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>